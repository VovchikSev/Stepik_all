# args = input().split()
# try:
#     Z = np.zeros(tuple(map(int, args)))
# except ValueError:
#     Z = np.zeros(tuple(map(int, args[:-1])), args[-1])


# 11 Считайте число n. Создайте единичную матрицу размера n, сохраните результат в переменную Z.
# import numpy as np
# Z = np.eye(int(input()))
# print(Z)

# # 12 Считайте 3 числа: n, m, l.
# import numpy as np
# # Зафиксируйте значение генератора случайных чисел Numpy с помощью
# np.random.seed(42)
# # Создайте матрицу n*m*l из случайных чисел (от 0 до 1) и сохраните результат в переменную Z.
# Z = np.random.rand(*map(int, input().split()))


# 13
# Считайте 2 числа: n, m.
# Создайте матрицу n*m из случайных чисел (от 0 до 1).
# Выведите на печать значение минимального и максимального чисел в получившейся матрице (каждое с новой строки).
# import numpy as np
# np.random.seed(42)
# Z = np.random.rand(*map(int, input().split()))
# print(np.mean(Z))


# 14 Считайте 2 числа: n, m.
# Зафиксируйте значение генератора случайных чисел Numpy с помощью numpy.random.seed(42)
# Создайте матрицу n*m из случайных чисел (от 0 до 1).
# Найдите среднее значение для каждого из столбцов.
# Выведите на печать значение минимального и максимального среднего по столбцам (каждое с новой строки).
# import numpy as np
# np.random.seed(42)
# Z = np.random.rand(*map(int, input().split())).mean(axis=0)
# print(Z.min(), Z.max(), sep='\n')


# # 15 Считайте 2 числа: n, m. Создайте матрицу размера n*m такую что:
# # На границе матрицы будут стоять 1 Внутри матрицы будут стоять 0
# import numpy as np
# Z = np.zeros(tuple(map(int, input().split())))
# Z[1:-1, 1:-1] = 1
# print(Z)

# # 16 Имеется матрица Z
# # Добавьте вокруг имеющихся значений матрицы "забор" из 0.
# import numpy


# # 18.1 Считайте число n.
# # Создайте диагональную матрицу размера n*n. На главной диагонали должны быть числа от 1 до n.
# # Сохраните матрицу в переменную Z.
# import numpy as np
# Z = np.diag(np.arange(1, int(input()) + 1))


# # 18.2 Считайте 2 числа:
# # x - сдвиг для единственной ненулевой диагонали в матрице.
# # k - верхняя граница для интервала чисел на диагонали (т.е. если k = 5, то на диагонали будут
# # стоять числа 1, 2, 3, 4 и 5)
# # Договоримся о значениях x:
# # x = 0 - это главная диагональ матрицы
# # x<0 - диагональ сдвигается вниз на |x| ячеек (если x = -1, то первая не нулевая ячейка будет с координатами (1,0))
# # x>0 - диагональ сдвигается вправо на |x| ячеек (если x = 1, то первая ненулевая ячейка будет с координатами (0,1))
# # Сохраните такую матрицу в переменную Z.
#
# import numpy as np
# x, k = map(int, input().split())
# Z = np.diag(np.arange(1,k+1), x)


# # 19 (21)
# # Считайте 2 числа: n, m.
# # Создайте матрицу размера n*m и "раскрасьте" её в шахматную раскраску.
# # 0 - "чёрное"  1 - "белое" Ячейка с координатами (0, 0) всегда "чёрная" (т.е. элемент (0, 0) равен 0).
# import numpy as np
# n, m = map(int, input().split())
# Z = np.tile([[0., 1.], [1., 0.]], (1 + n // 2, 1 + m // 2))[:n, :m]


# # 20 Если у нас есть матрица (или numpy массив большей размерности), то её можно представить в линейном виде:
# # Идея в том, что можно каждому элементу матрицы поставить в соответствие индекс.
# # Функция numpy.unravel_index проводит обратную операцию - по индексу элемента определяет его "координаты" в матрице.
# import numpy as np
# Z = np.array([[0, 1, 2, 3],
#               [4, 5, 6, 7],
#               [8, 9, 10, 11]])
# i = 5
# # print(type(Z))
# # ind =
# print(np.unravel_index(i,  Z.shape))

s