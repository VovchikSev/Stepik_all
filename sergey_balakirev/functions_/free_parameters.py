
# def get_biggest_city(*args)->str:
#     return max(args, key=len)

# print(get_biggest_city("Питер", "Москва", "Самара", "Воронеж"))


# Далее проверяйте вхождение каждого ключа "type", "color", "closed", "width" в словаре kwargs.
# Если есть, добавляйте к выводу занчение
# def get_data_fig(*args, **kwargs):
#     out_list = [sum(args), *(kwargs[i] for i in ('type', 'color', 'closed', 'width') if i in kwargs)]
#     return  (sum(args), *kwargs.values())
#     # if kwargs:
#     #     return  (sum(args), kwargs.values(),)
#     # else:
#     #     return (sum(args))

# print(get_data_fig(5, 4, 9, 9, 9, 9))
# print(get_data_fig(5, 4, 9, 9, 9, 9, type=False, color='Yellow', closed=True, width=10))
# print(get_data_fig(5, 4, 9, 9, 9, 9, color='Yellow', type=False, closed=True, width=10))
# print(get_data_fig(5, 4, color='Yellow', type=False, closed=True))
# ПРАВИЛЬНЫЙ РЕЗУЛЬТАТ:
# (45, False, 'Yellow', True, 10)
# (45, False, 'Yellow', True, 10)
# (9, False, 'Yellow', True)

# print(get_data_fig(3, 4, 5))
# print( get_data_fig(3, 4, 5, type=True, color=256, closed=False, width=5))


# Большой подвиг 6. (Для закрепления предыдущего материала). Вводится таблица целых чисел (см. пример ниже) размером N x N
#  элементов (N определяется по входным данным). Эта таблица содержит нули, но кое-где - единицы. С помощью функции
# с именем verify, на вход которой передается двумерный список чисел, необходимо проверить, являются ли единицы
# изолированными друг от друга, то есть, вокруг каждой единицы должны быть нули.Рекомендуется следующий алгоритм.
# В функции verify производить перебор двумерного списка. Для каждого элемента (списка) со значением 1 вызывать еще одну
# вспомогательную функцию is_isolate для проверки изолированности единицы.
# То есть, функция is_isolate должна возвращать True, если единица изолирована и False - в противном случае.
# Как только встречается не изолированная единица, функция verify должна возвращать False.
# Если успешно доходим (по элементам списка) до конца, то возвращается значение True.
# Функцию выполнять не нужно, только определить.
# P. S. При реализации функции is_isolate не следует прописывать восемь операторов if.
# Подумайте, как это можно сделать красивее (с точки зрения реализации алгоритма).

# def verify(lst_in: list) -> bool:
#     result = True
#     for row_index in range(len(lst_in)-1):
#         for col_index in range(len(lst_in[row_index])-1):
#             if lst_in[row_index][col_index] + lst_in[row_index][col_index + 1] + lst_in[row_index + 1][col_index] + lst_in[row_index + 1][col_index + 1] > 1:
#                 result = False
#                 break
#     return result

# print(verify([[1, 0, 0, 0, 0], 
#               [0, 0, 1, 1, 0], 
#               [0, 0, 0, 0, 0], 
#               [0, 1, 0, 1, 0], 
#               [0, 0, 0, 0, 0]]))

# Значимый подвиг 7. (Для закрепления предыдущего материала). Объявите функцию с именем str_min, 
# которая сравнивает две переданные строки и возвращает минимальную из них 
# (то есть, выполняется лексикографическое сравнение строк). Затем, используя функциональный подход к программированию 
# (то есть, более сложные функции реализуются путем вызова более простых), реализовать еще две аналогичные функции:
# - с именем str_min3 для поиска минимальной строки из трех переданных строк;
# - с именем str_min4 для поиска минимальной строки из четырех переданных строк.
# Выполнять функции не нужно, только записать.

def str_min(str_1:str, str_2:str)->str:
    return